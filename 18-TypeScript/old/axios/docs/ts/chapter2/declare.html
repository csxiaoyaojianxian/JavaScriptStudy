<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>变量声明 | TypeScript 从零实现 axios</title>
    <meta name="description" content="学习使用 TypeScript 从零实现 axios 库">
    
    
    <link rel="preload" href="/test/ts/assets/css/0.styles.c2cb947e.css" as="style"><link rel="preload" href="/test/ts/assets/js/app.917f6765.js" as="script"><link rel="preload" href="/test/ts/assets/js/2.37b52d5a.js" as="script"><link rel="preload" href="/test/ts/assets/js/32.cfaeb610.js" as="script"><link rel="prefetch" href="/test/ts/assets/js/10.21890e8d.js"><link rel="prefetch" href="/test/ts/assets/js/11.def94429.js"><link rel="prefetch" href="/test/ts/assets/js/12.44ea3232.js"><link rel="prefetch" href="/test/ts/assets/js/13.e2f1f2f5.js"><link rel="prefetch" href="/test/ts/assets/js/14.fc93fc93.js"><link rel="prefetch" href="/test/ts/assets/js/15.30f6a6c4.js"><link rel="prefetch" href="/test/ts/assets/js/16.06de8140.js"><link rel="prefetch" href="/test/ts/assets/js/17.66632e8c.js"><link rel="prefetch" href="/test/ts/assets/js/18.f2a1c8de.js"><link rel="prefetch" href="/test/ts/assets/js/19.0ac5caf7.js"><link rel="prefetch" href="/test/ts/assets/js/20.66404894.js"><link rel="prefetch" href="/test/ts/assets/js/21.d6da67e6.js"><link rel="prefetch" href="/test/ts/assets/js/22.7cdc6f13.js"><link rel="prefetch" href="/test/ts/assets/js/23.f66fb9bd.js"><link rel="prefetch" href="/test/ts/assets/js/24.44517154.js"><link rel="prefetch" href="/test/ts/assets/js/25.a7aa9fec.js"><link rel="prefetch" href="/test/ts/assets/js/26.766bed94.js"><link rel="prefetch" href="/test/ts/assets/js/27.89ba01e9.js"><link rel="prefetch" href="/test/ts/assets/js/28.4131104b.js"><link rel="prefetch" href="/test/ts/assets/js/29.5b1d87a4.js"><link rel="prefetch" href="/test/ts/assets/js/3.a24e8667.js"><link rel="prefetch" href="/test/ts/assets/js/30.3490bd30.js"><link rel="prefetch" href="/test/ts/assets/js/31.deb880cc.js"><link rel="prefetch" href="/test/ts/assets/js/33.05467d59.js"><link rel="prefetch" href="/test/ts/assets/js/34.9e34bd2b.js"><link rel="prefetch" href="/test/ts/assets/js/35.0c0f25c1.js"><link rel="prefetch" href="/test/ts/assets/js/36.de925195.js"><link rel="prefetch" href="/test/ts/assets/js/37.f2da477e.js"><link rel="prefetch" href="/test/ts/assets/js/38.e027bf70.js"><link rel="prefetch" href="/test/ts/assets/js/39.7cbf6c4e.js"><link rel="prefetch" href="/test/ts/assets/js/4.e9a474e4.js"><link rel="prefetch" href="/test/ts/assets/js/40.5a3bf62b.js"><link rel="prefetch" href="/test/ts/assets/js/41.9db203d5.js"><link rel="prefetch" href="/test/ts/assets/js/42.329d76e1.js"><link rel="prefetch" href="/test/ts/assets/js/43.85fa3c5c.js"><link rel="prefetch" href="/test/ts/assets/js/44.29e7e69f.js"><link rel="prefetch" href="/test/ts/assets/js/45.9fa3a0f1.js"><link rel="prefetch" href="/test/ts/assets/js/46.dd5b2f48.js"><link rel="prefetch" href="/test/ts/assets/js/47.8105d691.js"><link rel="prefetch" href="/test/ts/assets/js/48.a0c7cf29.js"><link rel="prefetch" href="/test/ts/assets/js/49.7830450b.js"><link rel="prefetch" href="/test/ts/assets/js/5.f01959fc.js"><link rel="prefetch" href="/test/ts/assets/js/50.12a057ea.js"><link rel="prefetch" href="/test/ts/assets/js/51.5fa50254.js"><link rel="prefetch" href="/test/ts/assets/js/52.8b1b0c8b.js"><link rel="prefetch" href="/test/ts/assets/js/53.2ef3a354.js"><link rel="prefetch" href="/test/ts/assets/js/54.3c9e48ce.js"><link rel="prefetch" href="/test/ts/assets/js/55.1e7afde9.js"><link rel="prefetch" href="/test/ts/assets/js/56.382bc603.js"><link rel="prefetch" href="/test/ts/assets/js/57.e73dc51e.js"><link rel="prefetch" href="/test/ts/assets/js/6.2d34372c.js"><link rel="prefetch" href="/test/ts/assets/js/7.250f83f3.js"><link rel="prefetch" href="/test/ts/assets/js/8.2fc7533f.js"><link rel="prefetch" href="/test/ts/assets/js/9.e11ea58c.js">
    <link rel="stylesheet" href="/test/ts/assets/css/0.styles.c2cb947e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/test/ts/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript 从零实现 axios</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>初识 TypeScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter1/" class="sidebar-link">Introduction</a></li><li><a href="/test/ts/chapter1/install.html" class="sidebar-link">安装 TypeScript</a></li><li><a href="/test/ts/chapter1/start.html" class="sidebar-link">编写第一个 TypeScript 程序</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>TypeScript 常用语法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter2/type.html" class="sidebar-link">基础类型</a></li><li><a href="/test/ts/chapter2/declare.html" class="active sidebar-link">变量声明</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#var-声明" class="sidebar-link">var 声明</a></li><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#let-声明" class="sidebar-link">let 声明</a></li><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#const-声明" class="sidebar-link">const 声明</a></li><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#let-vs-const" class="sidebar-link">let vs. const</a></li><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#解构" class="sidebar-link">解构</a></li><li class="sidebar-sub-header"><a href="/test/ts/chapter2/declare.html#展开" class="sidebar-link">展开</a></li></ul></li><li><a href="/test/ts/chapter2/interface.html" class="sidebar-link">接口</a></li><li><a href="/test/ts/chapter2/class.html" class="sidebar-link">类</a></li><li><a href="/test/ts/chapter2/function.html" class="sidebar-link">函数</a></li><li><a href="/test/ts/chapter2/generic.html" class="sidebar-link">泛型</a></li><li><a href="/test/ts/chapter2/inference.html" class="sidebar-link">类型推断</a></li><li><a href="/test/ts/chapter2/advance.html" class="sidebar-link">高级类型</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 项目初始化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter3/require.html" class="sidebar-link">需求分析</a></li><li><a href="/test/ts/chapter3/init.html" class="sidebar-link">初始化项目</a></li><li><a href="/test/ts/chapter3/base.html" class="sidebar-link">编写基础请求代码</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 基础功能实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter4/url.html" class="sidebar-link">处理请求 url 参数</a></li><li><a href="/test/ts/chapter4/data.html" class="sidebar-link">处理请求 body 数据</a></li><li><a href="/test/ts/chapter4/header.html" class="sidebar-link">处理请求 header</a></li><li><a href="/test/ts/chapter4/response.html" class="sidebar-link">获取响应数据</a></li><li><a href="/test/ts/chapter4/response-header.html" class="sidebar-link">处理响应 header</a></li><li><a href="/test/ts/chapter4/response-data.html" class="sidebar-link">处理响应 data</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 异常情况处理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter5/error.html" class="sidebar-link">错误处理</a></li><li><a href="/test/ts/chapter5/enhance.html" class="sidebar-link">错误信息增强</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 接口扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter6/extend.html" class="sidebar-link">扩展接口</a></li><li><a href="/test/ts/chapter6/overload.html" class="sidebar-link">axios 函数重载</a></li><li><a href="/test/ts/chapter6/generic.html" class="sidebar-link">响应数据支持泛型</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 拦截器实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter7/interceptor.html" class="sidebar-link">拦截器设计与实现</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 配置化实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter8/merge.html" class="sidebar-link">合并配置的设计与实现</a></li><li><a href="/test/ts/chapter8/transform.html" class="sidebar-link">请求和响应配置化</a></li><li><a href="/test/ts/chapter8/create.html" class="sidebar-link">扩展 axios.create 静态接口</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 取消功能实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter9/cancel.html" class="sidebar-link">取消功能的设计与实现</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 更多功能实现</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter10/withCredentials.html" class="sidebar-link">withCredentials</a></li><li><a href="/test/ts/chapter10/xsrf.html" class="sidebar-link">XSRF 防御</a></li><li><a href="/test/ts/chapter10/upload-download.html" class="sidebar-link">上传和下载的进度监控</a></li><li><a href="/test/ts/chapter10/auth.html" class="sidebar-link">HTTP 授权</a></li><li><a href="/test/ts/chapter10/validateStatus.html" class="sidebar-link">自定义合法状态码</a></li><li><a href="/test/ts/chapter10/paramsSerializer.html" class="sidebar-link">自定义参数序列化</a></li><li><a href="/test/ts/chapter10/baseURL.html" class="sidebar-link">baseURL</a></li><li><a href="/test/ts/chapter10/static.html" class="sidebar-link">静态方法扩展</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 单元测试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter11/preface.html" class="sidebar-link">前言</a></li><li><a href="/test/ts/chapter11/jest.html" class="sidebar-link">Jest 安装和配置</a></li><li><a href="/test/ts/chapter11/helpers.html" class="sidebar-link">辅助模块单元测试</a></li><li><a href="/test/ts/chapter11/requests.html" class="sidebar-link">请求模块单元测试</a></li><li><a href="/test/ts/chapter11/headers.html" class="sidebar-link">headers 模块单元测试</a></li><li><a href="/test/ts/chapter11/instance.html" class="sidebar-link">Axios 实例模块单元测试</a></li><li><a href="/test/ts/chapter11/interceptor.html" class="sidebar-link">拦截器模块单元测试</a></li><li><a href="/test/ts/chapter11/mergeConfig.html" class="sidebar-link">mergeConfig 模块单元测试</a></li><li><a href="/test/ts/chapter11/cancel.html" class="sidebar-link">请求取消模块单元测试</a></li><li><a href="/test/ts/chapter11/more.html" class="sidebar-link">剩余模块单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>ts-axios 部署与发布</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter12/build-deploy.html" class="sidebar-link">ts-axios 编译与发布</a></li><li><a href="/test/ts/chapter12/demo.html" class="sidebar-link">引用 ts-axios 库</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>课程总结</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/test/ts/chapter13/summary.html" class="sidebar-link">课程回顾与总结</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="变量声明"><a href="#变量声明" aria-hidden="true" class="header-anchor">#</a> 变量声明</h1> <p><code>let</code> 和 <code>const</code> 是 JavaScript 里相对较新的变量声明方式。<code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 JavaScript 里常见一些问题。<code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。</p> <p>因为 TypeScript 是 JavaScript 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code>。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。</p> <p>如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p> <h2 id="var-声明"><a href="#var-声明" aria-hidden="true" class="header-anchor">#</a> var 声明</h2> <p>在 ES5 的时代，我们都是通过 <code>var</code> 关键字定义JavaScript 变量：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
</code></pre></div><p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。</p> <p>我们也可以在函数内部定义变量：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> message <span class="token operator">=</span> <span class="token string">'Hello World!'</span>

  <span class="token keyword">return</span> message
<span class="token punctuation">}</span>
</code></pre></div><p>并且我们也可以在其它函数内部访问相同的变量：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> b
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// returns 11</span>
</code></pre></div><p>上面的例子是一个典型的闭包场景，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问 <code>a</code>。</p> <h3 id="作用域规则"><a href="#作用域规则" aria-hidden="true" class="header-anchor">#</a> 作用域规则</h3> <p><code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">shouldInitialize</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>shouldInitialize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> x
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment">// returns '10'</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment">// returns 'undefined'</span>
</code></pre></div><p>有些同学可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明的作用域是函数作用域，函数参数也使用函数作用域。</p> <p>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> sum <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> sum
<span class="token punctuation">}</span>
</code></pre></div><p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p> <h3 id="捕获变量怪异之处"><a href="#捕获变量怪异之处" aria-hidden="true" class="header-anchor">#</a> 捕获变量怪异之处</h3> <p>猜一下下面的代码会返回什么：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>答案是，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
<span class="token number">10</span>
</code></pre></div><p>很多 JavaScript 程序员对这种行为已经很熟悉了，但如果你很不解也没有关系，因为你并不是一个人。 大多数人期望输出结果是这样：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">6</span>
<span class="token number">7</span>
<span class="token number">8</span>
<span class="token number">9</span>
</code></pre></div><blockquote><p>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。</p></blockquote> <p>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。<code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10</code>。</p> <p>一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时 <code>i</code> 的值：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 <code>i</code>，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p> <h2 id="let-声明"><a href="#let-声明" aria-hidden="true" class="header-anchor">#</a> let 声明</h2> <p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， <code>let</code> 与 <code>var</code> 的写法一致：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> hello <span class="token operator">=</span> <span class="token string">'Hello!'</span>
</code></pre></div><p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p> <h3 id="块作用域"><a href="#块作用域" aria-hidden="true" class="header-anchor">#</a> 块作用域</h3> <p>当用 <code>let</code> 声明一个变量，它使用的是块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">input<span class="token punctuation">:</span> <span class="token builtin">boolean</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">100</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// OK: 仍然能访问到 a</span>
    <span class="token keyword">let</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">return</span> b
  <span class="token punctuation">}</span>

  <span class="token comment">// Error: 'b' 在这里不存在</span>
  <span class="token keyword">return</span> b
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们定义了 2 个变量 <code>a</code> 和 <code>b</code>。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。</p> <p>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token string">'Oh no!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Catch it.'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Error: 'e' 在这里不存在</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
</code></pre></div><p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于<em>暂时性死区</em>。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code>a<span class="token operator">++</span> <span class="token comment">// TS2448: Block-scoped variable 'a' used before its declaration.</span>
<span class="token keyword">let</span> a
</code></pre></div><p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 ES2015，现代的运行时会抛出一个错误；然而，现今 TypeScript 是不会报错的。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// okay to capture 'a'</span>
  <span class="token keyword">return</span> a
<span class="token punctuation">}</span>

<span class="token comment">// 不能在'a'被声明前调用'foo'</span>
<span class="token comment">// 运行时应该抛出错误</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> a
</code></pre></div><p>关于<em>暂时性死区</em>的更多信息，查看这里 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener noreferrer">Mozilla Developer Network<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h3 id="重定义及屏蔽"><a href="#重定义及屏蔽" aria-hidden="true" class="header-anchor">#</a> 重定义及屏蔽</h3> <p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 1 个。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x
  <span class="token keyword">var</span> x

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> x
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的<code>x</code>，并且这是完全有效的代码，但这经常会成为 <code>bug</code> 的来源。幸运的是 <code>let</code> 的声明就不会这么宽松了。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment">// 错误，不能在 1 个作用域里多次声明 x</span>
</code></pre></div><p>并不是要求两个均是块级作用域的声明 TypeScript 才会给出一个错误的警告。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// Error: 干扰参数声明</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span>
  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">100</span> <span class="token comment">// Error: 不能同时具有 x 的两个声明</span>
<span class="token punctuation">}</span>
</code></pre></div><p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">condition<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">100</span>
    <span class="token keyword">return</span> x
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> x
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// returns 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment">// returns 100</span>
</code></pre></div><p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">sumMatrix</span><span class="token punctuation">(</span><span class="token parameter">matrix<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> currentRow <span class="token operator">=</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> currentRow<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> currentRow<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> sum
<span class="token punctuation">}</span>
</code></pre></div><p>这个版本的循环能得到正确的结果，因为内层循环的 <code>i</code> 可以屏蔽掉外层循环的 <code>i</code>。</p> <p>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好权衡一下。</p> <h3 id="块级作用域变量的获取"><a href="#块级作用域变量的获取" aria-hidden="true" class="header-anchor">#</a> 块级作用域变量的获取</h3> <p>每次进入一个作用域时，<code>let</code> 会创建一个变量的环境。就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p> <p>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。</p> <p>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。不仅是在循环里引入了一个新的变量环境，而且针对每次迭代都会创建这样一个新作用域，这就相当于我们在使用立即执行的函数表达式时做的事。所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span> <span class="token operator">*</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>会输出与预料一致的结果：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token number">6</span>
<span class="token number">7</span>
<span class="token number">8</span>
<span class="token number">9</span>
</code></pre></div><h2 id="const-声明"><a href="#const-声明" aria-hidden="true" class="header-anchor">#</a> const 声明</h2> <p><code>const</code> 声明是声明变量的另一种方式。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span>
</code></pre></div><p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。</p> <p>这很好理解，它们引用的值是不可变的。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> numLivesForCat <span class="token operator">=</span> <span class="token number">9</span>
<span class="token keyword">const</span> kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Kitty'</span><span class="token punctuation">,</span>
  numLives<span class="token punctuation">:</span> numLivesForCat
<span class="token punctuation">}</span>

<span class="token comment">// Error</span>
kitty <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'Tommy'</span><span class="token punctuation">,</span>
  numLives<span class="token punctuation">:</span> numLivesForCat
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// OK</span>
kitty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Jerry'</span>
kitty<span class="token punctuation">.</span>numLives<span class="token operator">--</span>
</code></pre></div><p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。接口一章有详细说明。</p> <h2 id="let-vs-const"><a href="#let-vs-const" aria-hidden="true" class="header-anchor">#</a> let vs. const</h2> <p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。与大多数泛泛的问题一样，答案是：依情况而定。</p> <p>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。使用 <code>const</code> 也可以让我们更容易的推测数据的流动。</p> <h2 id="解构"><a href="#解构" aria-hidden="true" class="header-anchor">#</a> 解构</h2> <h3 id="解构数组"><a href="#解构数组" aria-hidden="true" class="header-anchor">#</a> 解构数组</h3> <p>最简单的解构莫过于数组的解构赋值了：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> input
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span> <span class="token comment">// outputs 2</span>
</code></pre></div><p>这创建了 2 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> first <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> second <span class="token operator">=</span> input<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre></div><p>作用于函数参数：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> input<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>

<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span>
</code></pre></div><p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token comment">// outputs 1</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token comment">// outputs [ 2, 3, 4 ]</span>
</code></pre></div><p>你也可以忽略你不关心的尾随元素：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token comment">// outputs 1</span>
</code></pre></div><p>或其它元素：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> second<span class="token punctuation">,</span> <span class="token punctuation">,</span> fourth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="对象解构"><a href="#对象解构" aria-hidden="true" class="header-anchor">#</a> 对象解构</h3> <p>你也可以解构对象：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token string">'foo'</span><span class="token punctuation">,</span>
    b<span class="token punctuation">:</span> <span class="token number">12</span><span class="token punctuation">,</span>
    c<span class="token punctuation">:</span> <span class="token string">'bar'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span> <span class="token operator">=</span> o

</code></pre></div><p>这通过 <code>o.a</code> 和 <code>o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。</p> <p>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> <span class="token operator">...</span>passthrough <span class="token punctuation">}</span> <span class="token operator">=</span> o
<span class="token keyword">let</span> total <span class="token operator">=</span> passthrough<span class="token punctuation">.</span>b <span class="token operator">+</span> passthrough<span class="token punctuation">.</span>c<span class="token punctuation">.</span>length
</code></pre></div><h3 id="属性重命名"><a href="#属性重命名" aria-hidden="true" class="header-anchor">#</a> 属性重命名</h3> <p>你也可以给属性以不同的名字：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> newName1<span class="token punctuation">,</span> b<span class="token punctuation">:</span> newName2 <span class="token punctuation">}</span> <span class="token operator">=</span> o
</code></pre></div><p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 <code>&quot;a 作为 newName1&quot;</code>。 方向是从左到右，好像你写成了以下样子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> newName1 <span class="token operator">=</span> o<span class="token punctuation">.</span>a
<span class="token keyword">let</span> newName2 <span class="token operator">=</span> o<span class="token punctuation">.</span>b
</code></pre></div><p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型，仍然需要在其后写上完整的模式。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">}</span> <span class="token operator">=</span> o
</code></pre></div><h3 id="默认值"><a href="#默认值" aria-hidden="true" class="header-anchor">#</a> 默认值</h3> <p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">keepWholeObject</span><span class="token punctuation">(</span><span class="token parameter">wholeObject<span class="token punctuation">:</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">1001</span> <span class="token punctuation">}</span> <span class="token operator">=</span> wholeObject
<span class="token punctuation">}</span>
</code></pre></div><p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p> <h3 id="函数声明"><a href="#函数声明" aria-hidden="true" class="header-anchor">#</a> 函数声明</h3> <p>解构也能用于函数声明。 看以下简单的情况：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token punctuation">}</span><span class="token punctuation">:</span> <span class="token constant">C</span></span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>上面的代码是一个类型推断的例子，将在后续章节介绍。</p></blockquote> <p>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token string">'yes'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// OK, 默认 b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// OK, 默认 a: '', b = 0</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// Error, 一旦传入参数则 a 是必须的</span>
</code></pre></div><p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。</p> <h2 id="展开"><a href="#展开" aria-hidden="true" class="header-anchor">#</a> 展开</h2> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> bothPlus <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">...</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>second<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
</code></pre></div><p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second的</code> 一份浅拷贝。 它们不会被展开操作所改变。</p> <p>你还可以展开对象：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">'spicy'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">'$10'</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">'noisy'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>defaults<span class="token punctuation">,</span> food<span class="token punctuation">:</span> <span class="token string">'rich'</span> <span class="token punctuation">}</span>
</code></pre></div><p>search的值为 <code>{ food: 'rich', price: '$10', ambiance: 'noisy' }</code>。 对象的展开比数组的展开要复杂的多。像数组展开一样，它是从左至右进行处理，但结果仍为对象。这就意味着出现在展开对象后面的属性会覆盖前面的属性。因此，如果我们修改上面的例子，在结尾处进行展开的话：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> defaults <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">'spicy'</span><span class="token punctuation">,</span> price<span class="token punctuation">:</span> <span class="token string">'$10'</span><span class="token punctuation">,</span> ambiance<span class="token punctuation">:</span> <span class="token string">'noisy'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> search <span class="token operator">=</span> <span class="token punctuation">{</span> food<span class="token punctuation">:</span> <span class="token string">'rich'</span><span class="token punctuation">,</span> <span class="token operator">...</span>defaults <span class="token punctuation">}</span>
</code></pre></div><p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: 'rich'</code>，在这里这并不是我们想要的结果。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/test/ts/chapter2/type.html" class="prev">基础类型</a></span> <span class="next"><a href="/test/ts/chapter2/interface.html">接口</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/test/ts/assets/js/app.917f6765.js" defer></script><script src="/test/ts/assets/js/2.37b52d5a.js" defer></script><script src="/test/ts/assets/js/32.cfaeb610.js" defer></script>
  </body>
</html>
